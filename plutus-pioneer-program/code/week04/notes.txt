We'll be looking at IO as well:

public static int foo() {
    ... //example java code
}

... foo() .. foo() 

In Java code, the first and second call of foo can very well result in different integers.
There's no way to say that the first and second call are the same.

We'd say some "IO" happens in this Java code

In Haskell, the situation is different:

foo :: int
foo = ...

... foo ... foo ...

We don't know what the value of foo is, but we know that foo output in Haskell will be the same both times.

REFERENTIAL TRANSPARENCY is what this is called. Makes refactoring easier.

You need side effects to have effects on the world! We need results to happen. We need side effects for programs to have utility.
"Haskell is useless"