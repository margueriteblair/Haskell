import           Control.Monad             (void)
import           Language.Plutus.Contract
import qualified Language.PlutusTx         as PlutusTx
import           Language.PlutusTx.Prelude hiding (Applicative (..))
import           Ledger                    (Address, ValidatorCtx, scriptAddress)
import qualified Ledger.Constraints        as Constraints
import qualified Ledger.Typed.Scripts      as Scripts
import           Ledger.Value              (Value)
import           Playground.Contract

-- Plutus Core is the programming language in which scripts in the Cardano blockchain are written
-- PlutusTx is the libraries and compiler for compiling Haskell into Plutus core

--This contract in Plutus once compiled, will simulate the same wallet txs as "Hello, World"
--But this time, also allows each wallet the ability of two more functions: publish and redeem
newtype MyDatum = MyDatum Integer deriving newtype PlutusTx.IsData
PlutusTx.makeLift ''MyDatum --When we are sending from Haskell to Plutus core, we're telling Plutus Tx what the datatype is

newtype MyRedeemer = MyRedeemer Integer deriving newtype PlutusTx.IsData
PlutusTx.makeLift ''MyRedeemer --Need to make sure to 'makeLift' to be able to send between PlutusTX and PlutusCore

-- | This method is the spending validator (which gets lifted to
--   its on-chain representation).
-- Validation script always takes: a datum, a redeemer, and a validation context
-- Validation context is information about the context
-- "validateSpend" here is our validation context for the overall program
validateSpend :: MyDatum -> MyRedeemer -> ValidatorCtx -> Bool --To return true or false if the transaction succeeds and the redeemer has the code
validateSpend _myDataValue (MyDatum _myDataValue) (MyRedeemer myRedeemerValue) _ = _myDataValue == myRedeemerValue -- Please provide an implementation.

-- | The address of the contract (the hash of its validator script).
-- Function address, static function that returns an address. Generated by Plutus
-- This comes from our Ledger import
contractAddress :: Address
contractAddress = Ledger.scriptAddress (Scripts.validatorScript starterInstance)

--ScriptType, setting up our redeemer and datum
data Starter
instance Scripts.ScriptType Starter where
    type instance RedeemerType Starter = MyRedeemer
    type instance DatumType Starter = MyDatum

-- | The script instance is the compiled validator (ready to go onto the chain)
starterInstance :: Scripts.ScriptInstance Starter
starterInstance = Scripts.validator @Starter
    $$(PlutusTx.compile [|| validateSpend ||])
    $$(PlutusTx.compile [|| wrap ||]) where
        wrap = Scripts.wrapValidator @MyDatum @MyRedeemer

-- | The schema of the contract, with two endpoints.
type Schema =
    BlockchainActions
    --We can see here that publish takes in a tuple of Integer, Value
        .\/ Endpoint "publish" (Integer, Value)
        --Redeem just takes an integer
        .\/ Endpoint "redeem" Integer

contract :: AsContractError e => Contract Schema e ()
contract = publish `select` redeem --Infix haskell syntax for select publish redeem, meaning we'll either publish or redeem based off of what the user inputs

-- | The "publish" contract endpoint.
-- Wallet a will publish an amount of $ADA along with a keyword/number that will need to be guessed
-- by the receiving end wallet
--In this program, our validator script is what is actually going to be locking the $ADA
publish :: AsContractError e => Contract Schema e ()
publish = do
    (i, lockedFunds) <- endpoint @"publish"
    let tx = Constraints.mustPayToTheScript (MyDatum i) lockedFunds
    void $ submitTxConstraints starterInstance tx

-- | The "redeem" contract endpoint.
redeem :: AsContractError e => Contract Schema e ()
redeem = do
    myRedeemerValue <- endpoint @"redeem" --This is the redeemers guess to get the ADA
    unspentOutputs <- utxoAt contractAddress --utxoAt is a function to get the unspent ada inside of the contract address
    let redeemer = MyRedeemer myRedeemerValue --Now that we know our unspent ada, we cast our redeemer value to our redeemer datatype
        tx       = collectFromScript unspentOutputs redeemer --let is a syntax for variables
    void $ submitTxConstraintsSpending starterInstance unspentOutputs tx --if this works, the redeemer will get the $ADA

endpoints :: AsContractError e => Contract Schema e ()
endpoints = contract

mkSchemaDefinitions ''Schema

$(mkKnownCurrencies [])